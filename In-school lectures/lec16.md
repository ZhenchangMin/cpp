# Lec16: 虚函数与消息的动态绑定

## 消息的多态性

不同类型的对象可以处理相同的消息，但处理方式往往是不一样的，因此，同一条消息可以有不同的解释（处理）。

### 消息的静态绑定

一般情况下，在**编译时刻**根据对象的类型来决定采用哪一个消息处理函数，即采用**静态绑定**。

### 消息的动态绑定

在public继承中，由于基类的指针或引用可以指向或引用基类对象，也可以指向或引用派生类对象，这就存在一种特殊的多态性.
如果在基类和派生类中**都给出了对某条消息的处理函数**，那么，通过基类的指针或引用向它指向或引用的对象发送这条消息时，它会调用哪一个消息处理函数?

```cpp
class A
{	 int x,y;
  public:
	 void f();
};
class B: public A
{	 int z;
  public:
   	void f(); 
   	void g();
};

void func1(A& x)
{	......
	x.f(); //调用A::f还是B::f ?
    // A::f
	......
}
void func2(A *p)
{	......
	p->f(); //调用A::f还是B::f ?
    // A::f
	......
}
......
A a;
func1(a);
func2(&a);
B b;
func1(b);
func2(&b);
```

C++默认采用的是静态绑定！与声明函数时的参数类型一致，与传入的对象类型无关。
需要动态绑定，来使得通过传入的对象类型确定调用哪一个消息处理函数。

```cpp
class A
{		int x,y;
	public:
		virtual void f(); //虚函数
};
class B: public A
{		int z;
	public:
   		void f(); 
   		void g();
};
```

在基类中声明一个函数为虚函数，其他不变，这样就会动态绑定。

```cpp
A a;
func1(a); //在func1中调用A::f，因为传入的是A类型的对象
func2(&a); //在func2中调用A::f
B b;
func1(b); //在func1中调用B::f，因为传入的是B类型的对象
func2(&b); //在func2中调用B::f
```

### 虚函数

虚函数是指加了关键词virtual的成员函数。其格式为：
`virtual <成员函数声明>;`
虚函数有两个作用：

- 指定消息采用动态绑定。
- 指出基类中**可以被派生类重定义**的成员函数。

对于基类中的一个虚函数，**在派生类中定义的**、**与之具有相同型构**的成员函数是对基类该成员函数的重定义（或称**覆盖**，override）。
相同型构是指派生类中定义的成员函数：

- 名字、参数个数和类型与基类相应成员函数相同；
- 返回值类型与基类成员函数返回值类型**可以相同**，也可以是基类成员函数返回值类型的**public派生类**。

消息的动态绑定将绑定到派生类中**与基类同型构**的成员函数

```cpp
class A
{	 int x,y;
  public:
	 virtual void f(int);
};
class B: public A
{	 int z;
  public:
   	void f(int);  //对A中f的重定义
 	void f(double); //新定义的成员函数
   	void g();
};
......
A *p=new B;
p->f(1); //调用B::f(int)
p->f(1.0); //double转换成int，调用B::f(int) 为什么给的参数是double，不调用B::f(double)？
// 因为p首先是一个基类A的指针，所以只能调用基类中的虚函数，动态绑定到B::f(int)
```

如果这里没加virtual，那么p->f(1.0)就会调用A::f(int)，因为p是一个A类型的指针，B里面的f和A里面的f就没有关系。
不是虚函数，就不允许重定义。

```cpp
class A
{	 int x,y;
  public:
	 virtual void f(int);
};
class B: public A
{	 int z;
  public:
 	void f(double) override;
	void g();
};
```

这里f本来是想对A中的f重定义，但是写错了参数类型，所以加上一个override关键字，编译器会检查基类里面是否有同型构的虚函数，没有就会报错。

如果在派生类中给出了“完美”的重定义，不需要在之后的派生类中再重定义，可以在重定义时加上**final**。

```cpp
class A
{	 int x,y;
  public:
	 virtual void f(int);
};
class B: public A
{	 int z;
  public:
 	void f(int) final; //不允许在之后的派生类中再重定义
	void g();
};
class C: public B
{	 ......
  public:
 	void f(int); //Error，不能再重定义！
};
```

final还有一个作用：指出不允许被继承的类。

```cpp
class A final //不允许继承
{	......
};
class B: public A //Error
{	......
};
```

只有通过基类的指针或引用访问基类的**虚函数**时**才进行动态绑定**。
只要在基类中说明了虚函数，在派生类、派生类的派生类、...中，与基类同型构的成员函数都是虚函数（virtual可以不写）。
基类的构造函数和析构函数中对虚函数的调用不进行动态绑定，因为可能会使用还未初始化的数据成员。

```cpp
class A
{  ......
  public:
	A() { f(); }
	~A() { f(); }
	virtual void f();
	void g();
	void h() { f(); g(); }
};
class B: public A
{  .......
 public:
   B();
	~B();
	void f(); 
	void g(); 
};

A a;  //调用A::A()和A::f
a.f();  //调用A::f
a.g();  //调用A::g
a.h();  //调用A::h、A::f和A::g
//a消亡时会调用A::~A()和A::f

B b;  //调用B::B()、A::A()和A::f
b.f();  //调用B::f
b.g();  //调用B::g
b.h();  //调用A::h、B::f和A::g
//b消亡时会调用B::~B()、A::~A()和A::f


A *p;   //p是A类（基类）指针
p = &a; //p指向A类对象
p->f();  //调用A::f
p->g();  //调用A::g
p->h();  //调用A::h, A::f和A::g

p = &b;  //p指向B类对象
p->f();  //调用B::f
p->A::f(); //调用A::f，类名受限采用静态绑定
p->g();  //调用A::g，非虚函数采用静态绑定
p->h();  //调用A::h, B::f和A::g
p = new B;  //调用B::B(), A::A()和A::f
.......
delete p;  //只调用A::~A()和A::f ，
               //没调用B:~B()，因为p是A类指针，只调用A的析构函数
                 //没有把A的析构函数定义为虚函数！加了virtual就可以调用B的析构函数
```

通过基类指针访问派生类中重定义的成员函数，用动态绑定就行了。
通过基类指针访问派生类中新定义的成员，怎么办？
可以使用**强制类型转换**将基类指针转换为派生类指针。

```cpp
B *q = (B *)p; //将p转换为B类指针
q->g(); //调用B::g
```

但是这样不安全！

```cpp
A *p;
......
B *q=dynamic_cast<B *>(p);
if (q != NULL) q->g();
```

如果p指向的不是B类对象，q为空

那些时候需要定义虚函数？

- 在设计基类时，有时虽然给出了某些成员函数的实现，但实现的方法可能不是最好，今后可能还会有**更好的**实现方法。
- 在基类中根本无法给出某些成员函数的实现，它们必须由不同的派生类根据实际情况给出具体的实现。（**抽象类与纯虚函数**）
