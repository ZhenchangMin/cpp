# Lec12: 对象的赋值与转移赋值
## 赋值操作符`=`的重载
同一个类的两个对象如何赋值？
C++编译程序会为每个类定义一个**隐式的赋值操作**，其行为是：逐个成员进行赋值操作。对于普通成员，它采用常规的赋值操作。对于成员对象，则调用该成员对象类的赋值操作。

针对像`string`这样的类，隐式的赋值操作会指向**同一个空间**，导致错误，因此需要重载赋值操作符。

```cpp
class String
{  ......
String& operator = (const String& s) //赋值操作符=的重载
    {	if (&s == this) return *this;  //防止自身赋值：a=a
	delete []str; //归还str原来指向的空间，防止内存泄漏
	str = new char[s.len+1]; //申请新的空间
	strcpy(str,s.str); //把用于赋值的字符串复制到新空间中
    len = s.len; 
	return *this;
    }
};
```
这个重载函数的返回值类型为什么是`String&`而不是`void`？因为赋值操作符`=`的返回值是一个左值，可以出现在赋值语句的左边，例如：
```cpp
String a("hello"), b("world"), c("cpp");
a = (b = c); //为了实现这种连锁赋值，赋值操作符必须返回一个左值引用
```
注意：如果有成员对象，**自定义的**赋值操作符重载函数**不会**自动去调用成员对象类的赋值操作，需要在自定义的赋值操作符重载函数中**显式指出**。
```cpp
class A { ...... };
class B
{		A a;
		int x,y;
	public:
		......
		B& operator = (const B& b)
		{	if (&b == this) return *this; 
            a = b.a;//显式调用A类的赋值操作符重载函数，实现成员对象的赋值。
			x = b.x;
			y = b.y;
			return *this;
		}
}; 
```

注意：要区别下面两个“=”的不同含义。
```cpp
A a;
A b=a; //初始化，等价于：A b(a);，调用拷贝构造函数。
......
b = a; //赋值，调用赋值操作符重载函数。
```
为了区分这两种=的不同含义，建议初始化的时候使用括号或大括号，赋值的时候使用等号。
一般来讲，需要**自定义拷贝构造函数**的类通常也需要**自定义赋值操作符重载函数**。

当用于赋值的对象（等号右边的对象）是一个**临时或即将消亡的对象**时，目前的赋值操作符重载函数的实现效率有时是不高的。

```cpp
class A
{ char *p;
public:
    A(const char *str) 
    { p = new char[strlen(str)+1]; //申请空间
        strcpy(p,str); 
    }
    ~A() { if (p!=NULL) delete[]p; p = NULL; } //释放空间

    A& operator=(const A& x) //赋值操作符重载函数
    { if (&x == this) return *this; 
      if (p != NULL) delete []p; //归还老空间
      p = new char[strlen(x.p)+1]; //申请新空间
      strcpy(p,x.p); //内容复制
      return *this; 
    }
  ......
};


A f(); //返回一个A类的临时对象，会额外申请空间
int main()
{ A a("abcd"); //调用构造函数为a额外申请空间
   a = f();  //把f的返回值对象赋值给对象a，返回值对象消亡
             //1. 调用赋值操作符重载函数：为a归还老空间、
	    //    申请新空间并进行内容复制
	    //2. 函数f返回值象消亡，调用析构函数归还它的空间
} //对象a消亡，调用析构函数为a归还空间
```
为何效率不高？
因为`f()`的返回值对象是一个临时对象，调用赋值操作符重载函数时，必须为`a`**归还老空间**、**申请新空间**并进行**内容复制**。
而实际上`f()`的返回值对象马上就要消亡了，完全可以直接把它的空间“转移”给`a`，而不需要进行内容复制。

## 转移赋值操作符重载函数
为了解决前面的赋值效率不高的问题，可以定义一个**转移赋值操作符重载函数**（move assignment operator）。
类比转移构造函数。
```cpp
A& operator=(A&& x) //参数为右值引用类型：&&
```
当用于赋值的对象是一个临时的或即将消亡的对象时，
- 如果对象类中**有**转移赋值操作符重载函数，则会去调用它来实现对象的赋值。
- 否则将调用**普通的**赋值操作符重载函数来实现对象的赋值。
注意：系统**不会提供隐式的**转移赋值操作符重载函数！
```cpp
A& operator=(A&& x)
{ if (p != NULL) delete []p; //归还老空间
   p = x.p; //使用参数对象的空间（资源转移）
   x.p = NULL; //使得参数对象不再拥有原来的空间
   return *this; 
 }
```
这样可以省去申请新空间、内容复制的过程，提高了效率。

### 转移构造与转移赋值联合作用
A类中假设都定义了转移构造函数和转移赋值操作符重载函数
```cpp
A f()
{ A t("1234"); //t中申请空间
   ......
   return t;   //t中申请的空间转移到返回值对象中，调用转移构造函数
}
int main()
{ A a="abcd";
   ......
   a = f(); //赋值操作，调用转移赋值操作符重载函数
   ......
}
```