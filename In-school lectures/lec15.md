# Lec15: 继承－－派生类
## 代码复用
**代码复用**是指：在开发一个新软件时，把现有软件的一些代码拿过来用，其好处是：
- 提高开发效率
- 保证软件质量
不幸的是，不加修改地直接复用已有软件的代码往往比较困难，如何解决已有软件与新软件之间的代码差别？
传统的做法是修改（复制-粘贴）已有软件的源代码，该方式存在缺点：需读懂源代码、可靠性差、易出错，而且源代码有时难以获得

类的**继承机制**为解决代码复用提供了更好的途径：
对已有软件中不符合新软件要求的类，可以通过继承机制来实现修改。

## 继承
在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出**新功能的定义**或对已有类的某些功能进行**重新定义**（修改）。

### 基类与派生类
- 基类（**父类**）：已有的类
- 派生类（**子类**）：新定义的类

继承分为：单继承和多继承
- 单继承：一个类只有一个直接基类。
- 多继承：一个类有多个直接基类。

### 单继承
派生类只有一个直接基类。
```cpp
class <派生类名>:[<继承方式>] <基类名>
{	<成员说明表>
}; 
```
<继承方式>可以不加，默认为**private**。

```cpp
class A //基类
{		int x,y;
	public:
		void f();
		void g();
};
class B: public A //派生类
{		int z; //新成员
	public:
		void h(); //新成员
		void g(); //对A的成员函数g重定义？
			     //后面会详细介绍如何重定义。
};
```
派生类除了拥有新定义的成员外，基类的所有成员（基类的构造函数、析构函数和赋值操作除外）都属于它。
实际上，派生类的对象包含了基类的一个**子对象**。
定义派生类时一定要见到基类的定义。
```cpp
class A;  //声明，没有定义
class B: public A  //Error
{  int z;
  public:
   void h()
};
```
有关友元：
如果在派生类中没有显式指出，则基类的友元不是派生类的友元；
如果基类是另一个类的友元，而该类没有显式指出，则派生类不是该类的友元。

### 继承和封装的矛盾
派生类不能直接访问基类的私有成员。
但是在创造函数的时候，往往需要访问基类的私有成员，带来了继承和封装的矛盾。

### protected 访问控制
用 `protected` 说明的成员不能通过对象使用，但可以在派生类中使用。
缓解了继承和封装的矛盾。

C++类向外界提供两种接口：
- public：供类的实例用户使用（通过对象）
- protected：供派生类使用

一般情况下，应该把今后不太可能发生变化的、有可能被派生类使用的、不宜对实例用户公开的成员声明为protected。

### 派生类成员标识符的作用域
对基类而言，派生类成员标识符的作用域是**嵌套**在基类作用域中的。
如果派生类中定义了与基类**同名**的成员，则基类的成员名在派生类的作用域内**不直接可见**（被**隐藏**，Hidden），在派生类中访问基类同名的成员时要用基类名受限。
```cpp
class A //基类
{		int x,y;
	public:
		void f();
		void g();
};
class B: public A
{		int z;
  public:
		void f(); //隐藏了A的f！
		void h()
		{	f();  //B类中的f
			A::f();  //A类中的f，要受限地访问
		}
};
```
即使参数不同，只要函数名相同，就构成了**隐藏**。
不属于函数名重载，因为作用域不同。

也可以在派生类中使用using声明把基类中某个的函数名对派生类开放。
```cpp
class A //基类
{		int x,y;
	public:
		void f();
		void g();
};

class B: public A
{		int z;
	public:
		using A::f;
		void f(int); //带参数的f
		void h() 
		{	f(1);  //OK
			f();  //OK，等价于A::f();
		}
};
```

### 在派生类的**外部**访问基类成员
派生类的**用户**能访问从基类继承来的哪些成员？
```cpp
class A// 基类
{	public:
		void f();
	protected:
		void g();
	private:
		void h();
};
class B: ... A// 派生类
{      ......
};
//B的用户1，实例用户
void func()
{ B b;
   b.f(); //?
   b.g(); //?
   b.h(); //?
}
//B的用户2，派生类用户
class C: public B
{	public:
		void r()
		{	f(); //?
			g(); //?
			h(); //?
     }
};
```
由继承方式和基类的访问控制权限共同决定。

### 继承方式
```cpp
class <派生类名>:[<继承方式>] <基类名>
{	<成员说明表>
}; 
```
继承方式可以是：
- public：公有继承
- protected：保护继承
- private：私有继承

用来规定派生类中**从基类继承来的成员**的访问权限。
![1760942336697](image/lec15/1760942336697.png)
回到刚才的问题
```cpp
class A// 基类
{	public:
		void f();
	protected:
		void g();
	private:
		void h();
};
class B: protected A// 派生类，假设继承方式为protected
{       // f 是protected
        // g 是protected
        // h 不可访问
        public:
	    void q() //新成员 
	    {  f(); //OK
	       g(); //OK
	       h(); //无法访问
	    }// 新成员，与b的继承方式没有任何关系，因为不是从基类继承来的，这里能否访问看基类中是否是public或者protected的

};
//B的用户1，实例用户
void func()
{ B b;
   b.f(); //不可访问
   b.g(); //不可访问
   b.h(); //不可访问
   b.q(); //OK，因为B类中q是public的
}
//B的用户2，派生类用户
class C: public B
{	public:
		void r()
		{	f(); //OK，因为是protected继承
			g(); //OK，因为是protected继承
			h(); //不可访问
            q(); //OK，因为C类是B类的派生类，而B类中q是public的
     }
};
```
