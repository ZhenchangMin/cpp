# Lec1 C++语言概述
## C++与C的关系
C++包含了C的所有成分,在C的基础上增加了一些新的语言机制

## 复习：函数指针
当一个函数要作为参数传入另一个函数时，需要使用函数指针。

## C++对C的基本扩充
* 局部变量的定义位置：允许局部变量的定义可以夹插在语句中
* 常量定义：
```c
#define PI 3.1416
```
C的做法，编译预处理命令
```cpp
const double PI=3.1416;
```
C++的做法，便于编译时进行类型检查
* 表示条件的表达式:
值非0表示满足，0表示不满足（C的做法）
bool类型：true表示满足，false表示不满足（C++扩充的，便于理解）
* 内联（inline）函数
* 名空间（namespace）
* 标准库
* 动态变量的内存分配
* 引用类型
* 函数名重载
* 类型自动判断auto
* 结构化异常处理
* 类型安全的输入输出

### 类型安全的输入输出
假设现在有变量x,y:
```c
int x;
double y;
```
c语言的输入输出：
```c
#include <stdio.h>
scanf("%d%lf",&x,&y);//类型不安全
printf("%d,%lf\n",x,y);//类型不安全
```
C++的输入输出：
```cpp
#include <iostream>
using namespace std;

cin>>x>>y;
cout<<x<<y;
//自动判断输入数据的类型和个数。
	   //cin为特殊类型的变量（对象），“>>”为重载的操作符
	   //cout为特殊类型的变量（对象），“<<”为重载的操作符
```
### 解决对小函数调用的低效问题
函数调用是需要额外开销的：
* 保留返回地址
* 为局部变量和形参分配空间
* 实现参数传递
* 返回时，归还空间、根据返回地址返回调用点
对一些函数体只包含一两条语句的**小函数**，函数调用的额外开销往往大于完成函数功能所需要的开销，它会使得频繁地调用这样函数的程序效率不高！
C++提供了两种解决上述问题的办法：
* 带参数的宏定义（C已有的）
* **内联函数**（C++扩充的）
#### 带参数的宏定义
带参数的宏定义是一种**编译预处理命令**，它可以实现类似函数的功能。
```c
#define max(a,b) ((a)>(b)?(a):(b))
```
在**编译之前**，编译预处理程序将对程序中宏的使用进行**文字替换**,然后交给编译程序进行编译。
例如，编译预处理程序将把程序中的
```cpp
cout << max(a,b);
```
替换成：
```cpp
cout << (((a)>(b))?(a):(b));
```
然后进行编译
**带参数的宏定义的缺点：**
1. 需要加上很多的括号，否则会出问题。
```c
#define max(x,y) x>y?x:y 
10+max(a,b)+c //将被替换成：
//10+a>b?a:b+c
//编译程序认为是：(10+a)>b?a:(b+c)
```
2. 有时会出现重复计算。
```c
max(a+1,b*2) 将被替换成：
//a+1>b*2?a+1:b*2
//a+1或b*2要计算2次
```
3. 不能进行类型检查和转换。
4. 不利于一些工具（如调试）对程序的处理。例如，在上面程序的编译结果中，max已不存在。

#### 内联函数
内联函数是指在定义函数时，在函数返回类型之前加上一个关键词**inline**。
```cpp
inline int max(int x, int y)
{	return x>y?x:y;
}
```
内联函数的调用与普通函数的调用形式相同：
```cpp
int z=max(a,b);
```
内联函数的作用是**建议**编译程序把该函数的函数体展开到调用点，函数调用时直接执行函数体。
之所以是“建议”，是因为有些函数不适合展开，如递归函数，编译程序会忽略inline要求，按普通函数处理。

### 带缺省值的形式参数
在C++中允许在声明函数时，为函数的某些参数指定默认值。
```cpp
void print(int value, int base=10);
```
在对这些函数调用的地方，如果没有提供相应的实参，则相应的形参采用指定的默认值。
```cpp
print(32,2); //32传给value；2传给base
print(28); //28传给value；10传给base， 是默认值
```
指定函数参数默认值时的几点注意：
- 有默认值的形参应全处于形参表的右部。
```cpp
void f(int a, int b=1, int c); //Error，c没指定默认值
```
- 在不同的源文件中，对同一个函数的声明可以对它的参数指定不同的默认值。
- 在同一个源文件中，对同一个函数的声明只能对它的每一个参数指定一次默认值。

### 名空间作用域
对于一个由多个模块（源文件）构成的程序，有时会面临一个问题：
在一个模块中要用到在另外两个模块中定义的不同全局程序实体，而这两个全局程序实体的名字相同。
![Example when namespace is needed](namespace.png)
C++提供了**名空间**（namespace）机制来解决上述的名冲突问题： 
可以把全局标识符定义在一个名空间中，其作用域为该名空间。
当在一个名空间外部需要使用该名空间中定义的全局标识符时，需要用该名空间的名字来修饰或受限。
下面是一个使用名空间的例子：
![Example of namespace usage](namespace-a&b.png)

**注意**：由于C++标准库中的全局实体（如cin、cout）是定义在名空间std中的，因此，使用标准库中的全局实体时要用std受限。
```cpp
using namespace std;
```

具有文件作用域的标识符可以用**无名的名空间**来定义。
例如，对于下面用static说明的具有文件作用域的全局变量：
```c
static int x,y; //C语言的做法
```
可以改写成：
```cpp
namespace
	{  int x,y; //x和y只能在本源文件中使用！
	}
```
**注意**：C++中，static有两个作用：
- 指定全局标识符具有文件作用域（可用无名的名空间替代）
- 指定局部变量具有静态生存期

### 动态变量
动态变量是指在程序运行中，由程序根据需要额外创建的变量，主要用于表示**元素个数可变**的复合数据，如链表、树等。
**注意**：动态变量没有名字，需要通过指向它的**指针变量**来标识和访问。
**在C语言中**，动态变量是用**库函数**来创建和撤销的。例如：
```c
int *p1; //p1是个指针变量, 创建一个int型动态变量，p1指向之
p1 = (int *)malloc(sizeof(int));
int *p2; //p2是个指针变量,创建一个由n个int型元素构成的动态数组，p2指向其第一个元素
p2 = (int *)calloc(n,sizeof(int)); //元素初始化为0
free(p1);
free(p2);
```
**在C++语言中**，增加了创建和撤销动态变量的两个操作符**new**和**delete**，提高类型安全性。
```cpp
int *p1; //p1是个指针变量
p1 = new int; //C++扩充，空间大小自动确定
int *p2; //p2是个指针变量
p2 = new int[n]; //C++扩充
delete p1;
delete []p2; //由于p2指向的是一个数组，所以要加[]
```
一般来说，
用new创建的动态变量需要用delete来撤销
用malloc（calloc）创建的动态变量则需要用free撤销

**注意**：对于普通的动态变量，C++与C的做法区别不大，但如果创建的是**动态对象**，则两者是有差别的：
除了为对象分配空间外，new还会去调用对象类的**构造函数**进行对象初始化， malloc（calloc）则否。
除了收回为对象分配的空间外，delete还会去调用对象类的**析构函数**进行对象消亡后的清理工作，free则否。

### 程序实体在内存中的安排
程序运行时，程序中的实体将存储在四个区域中：
**静态数据区**：用于**全局变量**、**static**存储类的局部变量以及一些常量的内存分配 。
**代码区**：用于存放程序的指令，对C++程序而言，代码区存放的是**所有函数代码**。
**栈区**：用于自动存储类的局部变量、函数的形式参数以及函数调用时有关信息（如：函数返回地址等）的内存分配。采用栈结构管理
**堆区**：用于**动态变量**的内存分配。常采用堆结构管理。

### C/C++动态变量存在的问题
C++没有**自动废区收集功能**，如果用原始的指针来标识和访问动态变量，往往需要程序显式地用**free**或**delete**来撤销它们，否则会出现**内存泄漏问题**

### 引用类型
引用类型是用来给一个变量取一个别名，通过该别名可以访问原来的变量。
```cpp
int x;
int &y=x; //y为引用类型的变量，它是x的别名
y = 10;  //通过y访问x，效果上等价于：x = 10;
cout << x; //输出10
```
引用类型具有指针类型的一些效果，但语法不一样。引用主要用于函数的参数类型，实现指针类型参数的效果，但它比指针类型抽象和安全。
例如，用引用类型提高函数参数传递的效率：
```cpp
struct A
{ int i;
   ......
};
void f(A &x) //x使用实参a的内存空间，提高参数传递效率
{ ......
   … x.i … //访问的是实参a
   ......
}
int main()
{ A a;
   ......
   f(a); //把a传给函数f
   ......
}
```

再例如，用引用类型实现通过形参改变实参的值。
```cpp
#include <iostream>
using namespace std;
void swap(int &x, int &y) //交换两个int型变量的值
{	int t;
	t = x;
	x = y;
	y = t;
}
int main()
{	int a=0,b=1;
	cout << a << ',' << b << endl; //结果为：0,1
	swap(a,b);
	cout << a << ',' << b << endl; //结果为：1,0
	return 0;
}
```

引用类型能保证通过形参访问的永远是实参数据。
```cpp
void f(int *p) //指针类型的形参
{ ... *p ... //访问的是实参a
   int m;
   p = &m; //OK，p指向的可以变量改变
   ... *p ... //访问的是m，即通过p可以访问实参以外的数据
}
void g(int &x) //引用类型的形参
{ ... x ... //访问的是实参a
   int m;
   x = &m; //Error，编译出错！
   … x … //访问的是a ，即通过x只能访问实参数据
}
```
相当于是int *const p，也能实现这样的效果。
也可以用const int &x，这样就不能通过x改变实参a的值。

函数的返回值是引用类型时，相当于复制一份返回，不是原来的变量。
```cpp
struct A
{	int n;
	......
};
A func1(const A &x)
{ ...... 
   return x; //把x（也就是a）复制一份返回
}
A& func2(const A &x)
{ ...... 
   return x; //把x（也就是a）返回
}
......
```
如果我调用func1(a)，返回的是a的副本，不是a本身，修改func1(a).n不会改变a.n。

```cpp
struct A
{	int n;
	......
};
A func1(const A &x)
{ ...... 
   return x; //把x（也就是a）复制一份返回
}
A& func2(const A &x)
{ ...... 
   return x; //把x（也就是a）返回
}
......
```
在这里，func2是A&类型，返回的是a本身，修改func2(a).n会改变a.n。

注意：不要把局部量的引用返回给调用者。函数返回之后，局部量的内存空间已经无效。

### 函数名重载
在相同的作用域中，可以用**同一个名字**定义多个不同的函数，这时，要求定义的这些函数应具有**不同的参数**（参数**个数或类型**要有所不同）。

#### 对重载函数调用的绑定
确定一个对重载函数的调用对应着哪一个重载函数定义的过程称为绑定（binding）。
C++对重载函数调用的绑定是在**编译时刻**由编译程序根据**实参与形参的匹配情况**来决定的。
绑定规则：按以下次序选择一个：
1. 精确匹配
2. 提升匹配
3. 标准转换匹配
4. 自定义转换匹配
5. 匹配失败

##### 精确匹配
实参与形参的类型完全相同，或者对实参进行“微小”的类型转换后与形参类型相同：
- 数组变量名->数组第一个元素的内存地址
- 函数名->函数的内存首地址

##### 提升匹配
对实参进行下面的类型提升，然后进行精确匹配：
- 按整型提升规则提升实参类型
- 把float类型实参提升到double
- 把double类型实参提升到long double
例如，对于下述的重载函数：
```cpp
void print(int);
void print(double);
```
根据提升匹配，下面的函数调用：
```cpp
print('a'); //绑定到函数：void print(int);
print(1.0f); //绑定到函数：void print(double); 
```

##### 标准转换匹配
先进行下面的标准转换，然后进行精确匹配：
- 任何算术类型可以互相转换
- 枚举类型可以转换成任何算术类型
- 零可以转换成任何算术类型或指针类型
- 任何类型的指针可以转换成void * 

##### 绑定失败
不存在匹配或者存在多个匹配。
例如，对于下述的重载函数：
```cpp
void print(int);
void print(double);
```
下面的函数调用是绑定失败的：
```cpp
print(1); //绑定失败
```

### 变量初始化
```cpp
int x{5}; //或 int x(5);  
int p1=new int{2}; //或 int p1=new int(2);      
int arr[5]{1, 2, 3, 4, 5};
int *p2=new int[5] {1, 2, 3, 4, 5};
struct Point { int x; int y;} point{10, 20};
struct Point { int x; int y;} *p3=new Point{10,20};
```

```cpp
int x = 1;// 初始化
x = 2; // 赋值
//等于号有两个意义，为了避免，cpp在初始化时可以使用花括号或者括号
```

### 基于范围的for
C++语言注重程序的效率，运行时刻不对数组元素下标越界进行检查。
```cpp
int a[10],sum;
sum=0; 
for (int n: a) sum += n; //不能改变元素的值
for (int &n: a) cin >> n; //可改变元素的值
```

### 类型自动判断：auto
在C++11中，关键词auto有新的含义：
- 定义一个变量时可以不指定它的类型，由编译器根据初始化的值**自动确定它的类型**。例如：
auto x=1+2*3.4; //编译程序自动确定x的类型为double

### 匿名函数：$\lambda$表达式
对一些临时使用的简单函数，可以把函数的定义和使用合二为一。
求定积分的函数：
```cpp
double integrate(double (*fp)(double), //函数指针
double a, double b);

integrate([](double x)->double { return x*x; },0,1);
//使用lambda表达式
```
常用格式：
[<环境变量使用说明>](<形参>) -> <返回值类型> { <函数体> }
形参：加圆括号，如果没有参数这项可以省略。
返回值类型：如果函数体只有一条return语句，且返回值类型可以自动确定，这项可以省略。
**环境变量使用说明：**
指出函数体中对外层作用域中的自动变量的使用限制。
- 空：不能使用外层作用域中的自动变量
- &：按引用方式使用外层作用域中的自动变量，可以改变这些变量的值
- =：按值方式使用外层作用域中的自动变量，不能改变这些变量的值
- 变量名：前面可以加&或者=，默认加=，相当于指定特定的自动变量

**使用示例：**
```cpp
{ int k,m,n; //环境变量，在外层作用域中
   ......
   ...[](int x)->int { return x*x; }... //不能使用k、m、n
   ...[&](int x)->int { k++; m++; n++; 
               return x+k+m+n; }... //k、m、n可以被修改
   ...[=](int x)->int { return x+k+m+n; }...
					//k、m、n不能被修改
   ...[&,n](int x)->int { k++; m++; 
                         return x+k+m+n; }... //n不能被修改
   ...[=,&n](int x)->int { n++; return x+k+m+n; }... 
                                          //n可以被修改
   ...[&k,m](int x)->int { k++; return x+k+m; }...   
                                    //只能使用k和m，k可以被修改
   ...[=] { return k+m+n; }... //没有参数，返回值类型为int
				
}
```
λ表达式的使用方式：
- 直接调用它定义的函数。例如：
```cpp
[](int x)->int { return x*x; }(10)
```
- 把它定义的函数作为参数传给另一个函数。例如：
```cpp
void f(int (*fp)(int)) { ... fp(x) ... }
......
f([](int x)->int { return x*x; })
```