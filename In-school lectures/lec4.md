# Lec4：对象与类
## 类
对象的特征要用相应的类来描述
class <类名> { <成员描述> } ;
成员包括：数据成员和成员函数。
### 例子：在cpp中定义日期类
```cpp
class Date
{
public:
	void set(int y, int m, int d) //成员函数
	{ year = y; month = m; day = d;
	}
	bool is_leap_year() //成员函数
	{ return (year%4==0 && year%100!=0) || (year%400==0);
	}
	void print() //成员函数
	{ cout << year << "." << month << "." <<day;
	}
   ......
private:
	int year,month,day; //数据成员
};
```

### 数据成员
对对象所包含的数据（属性）描述，它们可以是常量或变量，类型可以是任意的C++类型（void除外）。
```cpp
class Date //类定义
{		......
	int year,month,day;  //数据成员描述
};
```
在类中说明一个数据成员的类型时，如果未见到相应类型的定义，或者还没有定义完（如在Date中创造Date成员时，Date类还没有定义完，会递归），则该数据成员的类型只能是这些类型的**指针或引用类型**。
```cpp
class A;	//A是在程序其它地方定义的类，这里是声明。
class B
{	A a; //Error，未见A的定义。
	B b; //Error，B还未定义完，递归了！
	A *p;  //OK
	B *q;  //OK
	A &aa; //OK
	B &bb; //OK
}; 
```

### 成员函数
成员函数的实现可以放在类定义之外，例如：
```cpp
class A
{	 ......
    void f(); //声明
};
void A::f() { ... } //要用类名受限
```
如果函数体放在类定义中，默认建议编译器将其作为内联函数处理，所以适合小函数。

类成员标识符的作用域为**整个类定义范围**，也就是不分先后定义的顺序，类中前面的成员定义可以使用后面定义的成员名。
成员函数名是**可以重载**的，它遵循一般函数名的重载规则。例如：
```cpp
class A
{		......
		void f();
		int f(int i);
		double f(double d);
};
```

注意：在C++中，也允许在结构（struct）和联合（union）中定义函数。

### 类成员的访问控制
在C++的类定义中，可以用下面的成员访问修饰符来控制外部对类成员的访问限制：
- public：访问不受限制
- private：只能在本类和友元的代码中访问
- protected：只能在本类、友元和派生类的代码中访问，为了继承服务而设的访问权限。

友元：与类密切相关，又不适合作为类的成员或者派生类的情况。
例如：
```cpp
class A
{	public: //访问不受限制。 
		int x;
		void f();
	private: //只能在本类和友元的代码中访问。 
		int y;
		void g();
	protected: //只能在本类、友元和派生类的代码中访问。 
		int z;
		void h();
    public:
        int m;
};
```
在C++的类定义中，可以有多个public、private和protected访问控制说明；默认访问控制是private。
对于结构（struct）和联合（union）的成员，其默认访问控制是public。

一般来说，类的**数据成员**和在类的**内部使用的成员函数**应该指定为private，只有提供给**外界使用**的成员函数才指定为public。 
具有public访问控制的成员构成了类与外界的一种**接口**（interface）。
protected类成员访问控制具有特殊的作用（可以**在派生类中使用**）。

## 对象
类属于类型范畴的**程序实体**，它一般存在于静态的程序（编译程序看到的）中。
而动态的面向对象程序（运行中的）则是由**对象**构成。对象在程序运行时根据相应的类来创建。

### 对象的创建和标识 
#### 直接方式
通过在程序中定义一个类型为类的变量来实现。对象在进入相应变量的生存期时创建，通过**变量名**来标识和访问。相应变量的生存期结束时，对象消亡。
分为：全局对象、局部对象。

#### 间接方式
在程序运行时刻，用`new`操作符来创建对象（称为动态对象），用`delete`操作符来撤消它（使之消亡）。动态对象需要通过**指针**来标识和访问。
单个动态对象的创建与撤消
```cpp
A *p;
p = new A;  // 创建一个A类的动态对象。
… *p … //通过p访问动态对象
delete p;   // 撤消p所指向的动态对象。
```
动态对象数组的创建与撤消
```cpp
A *q;
q = new A[100];   //创建一个动态对象数组。
...q[i]... //或，*(q+i)，访问动态对象数组中的第i个对象
delete []q;   //撤消q所指向的动态对象数组。 
```

### 成员对象
对于类的数据成员，其类型可以是另一个类。即一个对象可以包含另一个对象，后者称为成员对象。
成员对象跟随包含它的对象一起创建和消亡。

### 对象的操作
对象的操作（访问对象的数据）是通过向对象**发送消息**（调用对象类中定义的某个public成员函数）来实现的。例如：
```cpp
class A
{	int x;
public:
	void f();
};
int main()
{A a; 	//创建A类的一个局部对象a。
a.f(); 	//调用A类的成员函数f对对象a进行操作。
A *p=new A;	 //创建A类的一个动态对象，p指向之。
p->f(); 	//或(*p).f();调用A类的成员函数f对p所指向的对象进行操作。
delete p; //p指向的动态对象消亡
return 0; //对象a消亡
}
```
在类的外部访问类的成员时要受到**类成员访问控制**的限制。
同类对象之间的赋值，把一个对象的所有数据成员值赋给另一个对象的数据成员。

把对象作为参数传给函数。例如：
```cpp
void f(Date d) //创建一个新对象d，用实参对象的数据成员对其初始化
{ ...... 
}
void g(Date &d) //不创建新对象，d只是别名，实际上d就是实参对象！
{ ...... 
}
Date today;
f(today); //调用函数f，对象today不会被f修改
g(today); //调用函数g，对象today能被g修改！
```

把对象作为函数的返回值。例如：
```cpp
Date f(Date &d)
{ d.print(); //输出：2020.2.20
return d;  //创建一个临时对象作为返回值，用d对其初始化，因为返回的不是引用
}
Date& g(Date &d)
{ d.print(); //输出：2020.2.20
return d;  //不创建新对象，把对象d作为返回值，因为返回的是引用
}
Date some_day; //创建一个日期对象
some_day.set(2020,2,20); 
f(some_day).set(2017,3,13); 
some_day.print(); //显示：2020.2.20，因为修改的是临时对象，someday的值不变
g(some_day).set(2017,3,13); 
some_day.print(); //显示：2017.3.13，因为修改的是some_day
```