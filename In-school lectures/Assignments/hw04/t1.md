任务描述
本关任务：本题需要使用STL容器相关知识，为std::unordered_map添加自定义类的支持。

相关知识
在课堂上我们学习过了std::map，它内部将所有的键值对以有序的方式存储。STL中还提供了一种支持按无序方式存储键值对的关联容器std::unordered_map，你可以通过#include <unordered_map>来使用它。

std::unordered_map的使用方式和std::map几乎一样：

std::unordered_map<int, int> int_map;
int_map[3] = 1;
std::cout << int_map[3]; // 输出为1
如果我们希望std::unordered_map的键为一个我们自定义的类，可以使用如下方式：

class DataClass{
private:
  std::vector<int> data_;
public:
  DataClass(const std::vector<int>& data):data_(data) {}
    
  // 计算当前类的哈希函数，这里将所有的int进行相加
  int HashKey() const {
    int sum = 0;
    for(auto d: data_){
        sum += d;
    }
    return sum;
  }
  
  // 如果两个类的哈希值相同，通过该操作符判断两个类是否相等
  bool operator==(const DataClass& dc) const {
    ...
  }
};
struct DataClassHash {
  size_t operator()(const DataClass &dc) const {
    int hash_value = dc.HashKey();
    return std::hash<int>()(hash_value);
  }
};
具体使用方法如下：

std::unordered_map<DataClass, int, DataClassHash> data_map;
DataClass d({1});
data_map[d] = 1;
HashKey函数为当前类计算一个哈希值（哈希值如何计算没有固定规则，但是你需要尽可能保证不同类的哈希值不同），operator ==会在两个类的哈希值相同时被调用，用于判断两个类是否完全相同。DataClassHash会调用我们实现的HashKey并计算一个类型为size_t的哈希值，此处的逻辑你不用关心，后续的代码中也不用进行改动。

任务描述

为如下的DataClass类实现HashKey以及operator ==两个函数。两个DataClass相等当且仅当其data_中的所有std::string均相等。

class DataClass{
private:
  std::vector<std::string> data_;
public:
  DataClass(const std::vector<std::string>& data):data_(data) {}
  std::string HashKey() const {
    // Your code here
  }
  
  bool operator==(const DataClass& dc) const {
    // Your code here
  }
};
// 不需要改动！
struct DataClassHash {
  size_t operator()(const DataClass &dc) const {
    std::string str = dc.HashKey();
    return std::hash<std::string>()(str);
  }
};
测试说明
我们将测试你所编写的DataClass类能否保证两个内容相同的类（即data_成员中的每一个std::string均相同）可以被std::unordered_map识别为同一个键。

我们保证所有的std::string中只包含小写字母，并且不会出现空std::string。

以下样例仅为示例，与实际测试样例不同。

样例1
int main() {
      std::unordered_map<DataClass, int, DataClassHash> data_map;
    DataClass d({"a", "b"});
    data_map[d]++;
    
    DataClass test({"a", "b"});
    std::cout << data_map[test] << std::endl; // 1
    return 0;
}
样例2
int main() {
      std::unordered_map<DataClass, int, DataClassHash> data_map;
    DataClass d({"a", "b"});
    DataClass d2({"a", "b"});
    data_map[d]++;
    data_map[d2]++;
    
    DataClass test({"a", "b"});
    std::cout << data_map[test] << std::endl; // 2
    return 0;
}
样例3
int main() {
    std::unordered_map<DataClass, int, DataClassHash> data_map;
    DataClass d({"a", "b"});
    DataClass d2({"ab"}); // 请注意，d和d2并不相同！
    data_map[d]++;
    data_map[d2]++;
    
    DataClass test({"a", "b"});
    DataClass test2({"ab"});
    std::cout << data_map[test] << std::endl; // 1
    std::cout << data_map[test2] << std::endl; // 1
    return 0;
}