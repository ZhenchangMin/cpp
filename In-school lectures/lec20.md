# Lec20: 输入/输出
## 概述
输入输出简称I/O，是程序的重要组成部分
由具体的**标准库**的功能来提供
输入/输出操作往往是带**内存缓冲区**的，解决内存与外设存取速度不匹配问题，提高效率：
- 输出时，输出的数据先放内存缓冲区中，缓冲区**满了之后再实际输出到外设**。
- 输入时，先从外设输入一大块内容**放入内存缓冲区**，然后从缓冲区中**逐步输入**数据。

### printf、scanf的缺陷
过程式，从C语言的函数库保留而来的
printf和scanf是两个带可变参数的函数，它们的第一个参数为一个格式串，指出后面要输入/输出的**数据的类型和个数**。
类型不安全，可能导致类型或者个数不一致，造成运行错误

### cin、cout的优势
面向对象的输入输出，用相应的输入输出类和重载过后的`<<`和`>>`实现
不需要专门指定数据的类型和个数，**编译时刻**根据数据本身来决定数据的类型和个数，可以避免与类型和个数相关的错误

### I/O的分类
- 面向控制台的I/O，从标准输入设备（键盘）获得数据，运行结果从标准输出设备（显示器）输出
- 面向文件的I/O，从外存（磁盘）获得数据，运行结果保存在外存中
- 面向字符串变量的I/O，从程序中的字符串变量获得数据，把运行结果保存到字符串变量中

### C++的I/O类库中基本的类
![1762754770162](image/lec20/1762754770162.png)
istream只能输入，ostream只能输出
想要既能输入又能输出，就需要iostream这个类，是从istream和ostream**多继承**而来的

#### 基于I/O类库进行I/O的**基本步骤**
首先要创建某个I/O类的一个**对象**，然后，调用该对象类的**成员函数**进行基于**字节流**的输入/输出操作。

比如控制台输入：
```cpp
istream in(...); //创建istream类的一个对象in
in.get(ch); //读入一个字节，ch为一个字符变量
in.read(p,100); //每次读入100个字节，放入p中，p是内存空间首地址
```
控制台输出：
```cpp
ostream out(...); //创建ostream类的一个对象out
out.put(ch); //输出一个字节，ch为一个字符变量
out.write(p,100); //把p指向的内存中100个字节输出
```

标准库中的I/O类还针对输入/输出类分别重载了操作符`>>`（抽取）和`<<`（插入），用它们可以进行C++基本类型数据的输入/输出操作。
```cpp
//控制台输入
istream in(...);
in >> x; //x是一个基本数据类型的变量
in >> y; //y是一个基本数据类型的变量
//控制台输出
ostream out(...);
out << e1; //e1是一个表达式
out << e2; //e2是一个表达式
```
用操作符`>>`进行输入时，它把输入的内容看成是一个**字符串**，会自动进行从字符串到基本数据类型的**转换**。
用操作符`<<`进行输出时，它会把基本数据类型的数据**转换成字符串输出**。

## 面向控制台的I/O
在I/O类库中**预定义**了四个I/O对象，可以直接用来进行**控制台的输入/输出操作**
- cin：istream类的对象，对应**标准输入设备**
- cout：ostream类的对象，对应**标准输出设备**
- cerr和clog：ostream类的对象，对应着计算机系统用于输出**特殊信息**（如程序错误信息）的设备。（通常也对应着显示器，但不受**输出重定向**的影响）。cerr为不带缓冲的，clog为带缓冲的。

在进行控制台输入/输出时，程序中需要有 `#include <iostream>` 这个命令

输入/输出重定向：`C>program.exe <a.txt >b.txt`
程序中所有cin从文件a.txt中获得输入，<号代表输入的文件
程序中所有cout输出到文件b.txt中，>号代表输出的文件

### 控制台的输出操作
用插入操作符`<<`进行基本数据类型数据的输出
特殊情况：输出**指向字符的指针**时，并不是输出指针的值（地址），而是输出它指向的字符串。
如果要输出字符指针的值，需要把它转换成其它类型的指针，比如转换成void *类型

#### 输出格式控制
可以通过输出一些**操纵符**（manipulator）来实现
```cpp
#include <iostream>
#include <iomanip>  //操纵符声明的头文件。
using namespace std;
.....
int x=10;
cout << hex << x << endl; //以十六进制输出x的值，然后换行。
```
![1762755853959](image/lec20/1762755853959.png)
对于浮点数（float、double和long double）：
- 当输出格式为`ios::scientific`或`ios::fixed`时，操纵符setprecision用于设置浮点数**小数点后面的位数**
- 当输出格式为自动方式（既不是ios::scientific也不是ios::fixed，或两者同时设了）时，操纵符setprecision用于设置浮点数**有效数字的个数**，这时的输出格式根据有效数字自动确定。

除了用操作符`<<`进行基本数据类型的输出外，也可以用ostream类的成员函数进行**基于字节**的控制台输出操作。
```cpp
//输出一个字节。
ostream& ostream::put(char ch); 
cout.put('A');
//输出p所指向的内存空间中count个字节。
ostream& ostream::write(const char *p,int count);
char info[100];  
int n;
......
cout.write(info,n); 
```

### 控制台的输入操作
用抽取操作符`>>`进行基本数据类型数据的控制台输入。

用抽取操作符>>进行输入时，各个数据之间一般要用**空白符**（空格、\t、\n）分开：
输入一个数据前，先**跳过空白符**
输入一个数据的过程中，碰到空白符或当前数据类型**不允许的字符**时，**结束**当前数据的输入

可以通过一些**操纵符**来控制输入的行为
```cpp
char str[10];
cin >> setw(10) >> str; //把输入的字符串和一个'\0'放入str中，也就是最多输入9个字符
// 多的字符放在输入缓冲区之中。
// 如果不加这个函数，可能会让str这个空间出问题，被撑爆
```

除了用操作符`>>`进行基本数据类型的输入外，也可以用istream类的成员函数进行**基于字节**的控制台输入操作。
```cpp
//输入一个字节到ch中。
istream& istream::get(char &ch); 
//输入count个字节至p所指向的内存空间中。
istream& istream::read(char *p,int count);
//输入一个字符串放入p指向的内存空间中。输入过程直到输入了count-1个字符或遇到delim指定的字符为止，并自动在最后加上一个'\0'字符。
istream& istream::get(char *p, int count, char delim='\n'); 
istream& istream::getline(char *p, int count, char delim='\n');
```
用istream类的成员函数进行输入时，**空白符**也会作为字符输入！
因此如果要输入一个带空格的字符串，就用get或者getline，不会因为空白符结束

另外，可以用下面的成员函数**跳过**输入缓存中的若干字符
```cpp
cin.ignore(n,'\n'); //跳过输入缓存中n个字符，或碰到回车
//例如：
char str[5]; int x;
cin.get(str,5); //输入：abcdefg↙，只读入abcd，efg留在输入缓冲区中
cin.ignore(20,'\n'); //跳过输入缓冲区中遗留的efg
cin >> x; //输入：12↙，x得到12，它输入缓冲区中遗留的efg已经被跳过
```

### 操作符`>>`和`<<`的重载
重载之后的这两个操作符只能进行基本数据类型的输入输出
自定义类型的对象，可以再对这两个操作符进行自定义的重载，就可以进行自定义对象的输入输出

例子：实现复数类的输出
```cpp
class Complex
{  ......
    friend ostream& operator << (ostream &out, const Complex &c);
  private：
	double real;
	double imag;			
};
ostream& operator << (ostream &out, const Complex &c)
{	out << c.real << '+' << c.imag << 'i';
	return out;
}
.....
Complex c1,c2;
cout << c1 << endl << c2 << endl;
```

## 面向文件的I/O
用于永久性保存数据的设备称为**外部存储器**（简称：外存），比如磁盘、光盘等

### 文件
文件是外存（如磁盘）中组织数据的**基本单位**
每个文件都有一个名字（文件名），它由两部分构成：<主文件名>.<扩展名>
操作系统一般采用**树型**的目录结构来管理外存中的文件。一个文件在外存中的存储位置通常由一个**路径**来指出，路径上的每个结点是一个**文件夹**。

### 文件数据的存储方式
对于一个整数：-1234567，有两种存储方式：
- 文本方式：按字符串把字符：-、1、2、3、4、5、6、7的ASCII码依次写入文件。（共8个字节） 
- 二进制方式：按int型机内表示（补码：0xFFED2979），把它分成字节依次写入文件。（共4个字节）

- 文本方式
由可显示的字符和有限的几个控制字符的编码字节构成，一般用于存储具有“行”结构在文字数据，用记事本等软件可以查看

- 二进制方式
由任意没有显式含义的纯二进制字节构成，用于储存任意结构的数据，数据由对应的应用程序来解释

### 文件的读写过程
- 打开文件：把程序内部的一个表示文件的变量或者对象与外部的具体文件关联起来，创建内存缓冲区
- 文件读写：存取文件中的内容
- 关闭文件：把暂存在内存缓冲区中的内容写入文件，并且归还打开文件的时候申请的内存资源（包括内存缓冲区）

### 文件的位置指针
c++中把文件看成一系列字节构成的**字节串**，对文件中的数据的操作，通常是**逐个字节**顺序进行，因此称为**流式文件**
读入/写回第n个字节，首先要读入/写回前n-1个字节
每个打开的文件有一个内部隐藏的**位置指针**，指出文件的当前读写位置，每读写一个字节，位置指针会自动往后移动一个字节。

### 文件的输出操作
在利用I/O类库中的类进行**文件**的输入/输出时，程序中需要包含下面的头文件：  
```cpp
#include <iostream>  
#include <fstream>
```

**打开文件**：创建`ofstream`类的一个对象，并建立它与外部某个文件之间的联系。
- 直接方式：创建对象的同时就建立与外部文件的联系
```cpp
ofstream out_file(<文件名> [,<打开方式>]); // 创建ofstream的对象out_file
// 例如，下面创建的对象out_file对应文件myfile.txt：
ofstream out_file("d:\\myfile.txt",ios::out);
```

- 间接方式：先用默认构造创建一个对象，然后用open建立与外部文件的联系
```cpp
ofstream::open(<文件名> [,<打开方式>]);
// 例如，让对象out_file对应文件myfile.txt：
ofstream out_file; //用默认构造函数创建对象out_file
out_file.open("d:\\myfile.txt",ios::out);
```

#### 打开方式
- ios::out
打开一个外部文件用于写操作，如果外部文件已存在，则首先把它的**已有内容清除**；否则，先创建该外部文件（内容为空）。
ios::out是**默认打开方式**。

- ios::app（不是application，是append）
打开一个外部文件用于**添加操作**。（**不清除文件已有内容**，文件位置指针在末尾），如果外部文件不存在，则先创建该外部文件（内容为空）。 

- ios::out | ios::binary 或 ios::app | ios::binary
按**二进制方式**打开文件。（默认的是文本方式）
对以文本方式打开的文件，当输出的字符为'\n'时，在某些平台上（如：Windows平台）将会自动把它转换成'\r'和'\n'两个字符写入外部文件。 
对以二进制方式打开的文件，**对输出的字节不做任何转换，原样输出**。

#### 判断打开操作是否成功
一共有三种方式
```cpp
if (!out_file.is_open())  //或：out_file.fail() 
				            //或：!out_file，因为!操作符已经在这个类中重载过了
{ ...... //失败处理
} 
```

#### 输出数据
文件成功打开后，可以使用插入操作符“<<”或ofstream类的一些成员函数来进行文件数据的输出操作
```cpp
int x=12;
double y=12.3;
......
//按文本方式输出数据
ofstream out_file("d:\\myfile.txt",ios::out);
if (!out_file) exit(-1);
out_file << x << ' ' << y << endl; //写入文件：12 12.3

//按二进制方式输出数据
ofstream out_file("d:\\myfile.dat",ios::out|ios::binary);// 使用二进制方式打开
if (!out_file) exit(-1);
out_file.write((char *)&x,sizeof(x)); //输出：4个字节 取x的地址，转化为char型指针，然后按照字节数写入文件
// 写入的是32位补码形式，占4个字节
out_file.write((char *)&y,sizeof(y)); //输出：8个字节
```

文件输出操作结束时，要使用ofstream的成员函数`close`关闭文件：
```cpp
out_file.close(); 
```
关闭文件的目的：把文件**内存缓冲区**的内容写到外设文件中，并且归还打开文件时申请的资源
程序正常结束时，系统也会自动关闭程序打开的文件。

既然会自动关闭，为什么还要显式关闭？如果程序没有正常结束那么就不会把缓冲区里面的数据写入文件

### 文件的输入操作
打开文件：创建ifstream类的一个对象，并把它与外部文件建立联系。
```cpp
// 直接方式
ifstream in_file(<文件名> [,<打开方式>]);
// 间接方式
ifstream in_file; //用默认构造函数初始化
in_file.open(<文件名> [,<打开方式>]);
```

打开方式：
- ios::in
打开一个外部文件用于读操作。（默认）
- ios::in | ios::binary
按二进制方式打开文件。（默认为文本方式）

打开文件时要判断打开是否成功，判断方式与文件输出打开操作的判断一样。
从文件输入必须要知道文件中数据的**存储方式和格式**

读取数据过程中有时需要判断是否正确读入了数据（尤其是在文件末尾处）。
判断是否正确读入了数据，可以调用ios类的成员函数`fail`来实现：
`bool ios::fail() const;`
该函数返回true表示文件操作失败；返回false表示操作成功。 

![1762761291422](image/lec20/1762761291422.png)
![1762761408455](image/lec20/1762761408455.png)

### 有关文件读写的几点注意
以文本方式读写的文件要以文本方式打开；以二进制方式读写的文件要以二进制方式打开！
以文本方式输出的文件要以文本方式输入；以二进制方式输出的文件要以二进制方式输入！
不可混用

以二进制方式存取文件不利于程序的**兼容性和可移植性**
- 在不同**计算机平台**上，int型数据的各个字节在内存中的存储次序可能不一样（由低位到高位或由高位到低位）。
- 在不同的**编译环境**下，同样的一个结构类型数据所占的内存大小（字节数）可能不一样。

### 能同时进行输入/输出的文件 
如果需要打开一个**既能读入数据、也能输出数据**的文件，则需要创建一个fstream类的对象。 
文件内部有**两个位置指针**，一个用于读，另一个用于写。
在创建fstream类的对象并建立与外部文件的联系时，文件打开方式应为下面之一：
ios::in|ios::out（可在文件任意位置写）
ios::in|ios::app（只能在文件末尾写） 

### 文件的随机存取
![1762762423257](image/lec20/1762762423257.png)